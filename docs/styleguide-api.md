# Style Guide - API
## Goals
* An API that's _easy to learn and understand_ for developers new to our framework.
* A _consistent_ API, increasing predictability and intuitiveness.
* An API that's as _future-proof_ as we can rationally estimate.

## Understandability
Our job as framework engineers is to provide tools that make achieving a developer's goals easier and quicker. Anyone could go invent their own method or process for achieving their goals, but that's not often what developers want. They want few roadblocks in the path to their app shipping. We are here to hear what they need, find a way to do it better and provide it in a convenient way, to save developers time. In our specific case, this means doing the research on the best tools and way to do something, building it, and delivering tools, utilities, and components that are shortcuts to the larger harder path. There's always a harder way achieve your goals, but finding an easier way is our responsibility. If when developing a control or new API and there's a choice to be made, lean toward easier end-user usage and simpler API.

The simplicity of API interaction is valuable. When designing controls, here's some guidelines and suggestions:

* Choose Boolean property names that allow the default to be false. This will create nicer looking code for the developer that's easier to read when put into JSX. `<Button disabled />` is much clearer than  `<Button enabled={false} />` and although it has a negative directly in the property, `<Picker noAnimation />` is still nicer than `<Picker animated={false} />`.
* Shorter names for properties are usually better.
* Terminology should be descriptive of the concept, not the visual result in a particular visual library. This abstracts the code so it's universal and independent of what the component happens to look like right now.
* Generally, try to keep just one control per folder, unless you have a tightly-coupled set of components that shouldn't be apart. There's always exceptions, but it's good practice, for control discoverability and code maintainability, to keep them apart.

## Consistency
Consistency goes a long way for a framework. Internally, it makes future decisions easier by providing a structural plan to follow; and externally it makes the framework easier to use because components follow a predictable pattern. The ability to expect what an API would be ahead of time increases intuitiveness and generally means less time looking up documentation and more time developing. Consistency relates to everything from event names to properties; the more consistent we are across controls, the better our framework feels to use. It starts to feel more like magic than a chore.

Everyone who's ever written an interactive web form and had to talk to a `<select>` tag in the old days of the web can tell you how unintuitive it was the first time they tried to get values from it. The `<select>` tag differs from the other HTML form controls in that it doesn't offer its value in a consistent way –with respect to the other inputs– even though when the form is submitted, the value from it is indistinguishable from the rest. Instead of simply providing a `value` property, which always maps back to `select.options[select.selectedIndex].value`, the developer must do this step. That leads to great confusion by new developers and that inconsistency is something we can avoid with our framework. Thankfully this was corrected in more recent version of HTML. We recognize the trend, the behavior, that an input has, which is to provide a value. We standardize across our controls so almost any control could be a drop-in replacement for any other control with only a few minor contextual changes. Why should a numeric RangePicker component have a different API (properties and outputs) than a Slider component or a numeric text Input component? They're providing the same service, to return a number supplied by the user, so the properties related to that should sync-up and match. Obviously, some properties don't directly map, like `step`, and that's ok; that's a control UX implementation restriction that only exists on a numeric input. If we were to add a step feature to a numeric text Input, maybe the input only accepts numbers rounded to the nearest 5, we'd also want to call the property `step`, for API consistency, even though that may not seem to be the ideal name for such a feature, when looking at that control on its own.

## Future-proofing
True future-proofing is essentially impossible since the future is unknowable. However, due to what experience has taught us, we have a level of "big picture" understanding that grants us the ability to make some reasonable conclusions about what will likely happen in the future. We can, therefore, make decisions and lay the groundwork for such situations with that in mind.

We will be maintaining this framework for years to come. We'll soon be out of the initial alpha stage and have real clients that will require both API consistency and API stability.  Our motivation for a given name or feature can't simply be one-dimensional. We must look at long term maintainability; what will this API look like now, and what will it look like after a year or two of maintenance, with developers needing to add features and refactor code? Although this process can be time-consuming and seem mundane it will be better to spend the time and care now to aim for supporting future unseen scenarios and expansion than a quick solution that just works for now. How long will it inevitably be before we need to refactor a piece of code because we didn't anticipate expansion in that area? An example of this was Enyo 2's Header component. It originally had one size, and later a smaller one was added. To toggle between the two, a `small` Boolean property was added. This seemed fine at the time, but later an even smaller size was requested. This required refactoring to use a `type` property instead that accepts a string, and a maintenance cost of preserving the old API and converting it into the new system. Had the control just implemented a `type` field initially, the later refactor to add a new mode would have been much simpler.

A good rule of thumb when planning for situations like the above, is that if it can happen once, it could happen again. The initial design of the Header wasn't incorrect. It implemented its requirements as expected, but the refactor to add a `small` property could have been done with more consideration of the future requirements.

