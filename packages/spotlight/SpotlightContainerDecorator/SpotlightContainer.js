import {call, forProp, handle, not, stop} from '@enact/core/handle';

import {hasPointerMoved} from '../src/pointer';
import Spotlight from '../src/spotlight';

const isNewPointerPosition = (ev) => hasPointerMoved(ev.clientX, ev.clientY);

class SpotlightContainer {
	constructor ({containerConfig, navigableFilter, preserveId}) {
		// spotlight id - set either via props or generated by Spotlight
		this.id = null;

		// Preserve the spotlight id across instances when it is set via props and preserveId is set
		this.canPreserveId = preserveId;
		this.preserveId = false;

		// container config - set once when the container is added
		this.config = containerConfig;

		// optional filter function to limit the spottable candidates for this container
		this.filter = navigableFilter;

		// private hash of spotlight DOM attributes
		this.attr = {};

		// Used to indicate that we want to stop propagation on blur events that occur as a
		// result of this component imperatively blurring itself on focus when spotlightDisabled
		this.shouldPreventBlur = false;
	}

	get attributes () {
		return this.attr;
	}

	setProps ({disabled, id, muted, restrict}) {
		if (this.id == null || this.id !== id) {
			if (this.id) {
				this.releaseContainer(this.id);
			}

			this.id = Spotlight.add(id, {
				...this.config,
				restrict,
				navigableFilter: this.navigableFilter
			});
			this.preserveId = this.canPreserveId && this.id === id;
		} else {
			Spotlight.set(this.id, {restrict});
		}

		this.attr['data-spotlight-id'] = this.id;
		this.attr['data-spotlight-disabled'] = disabled;
		this.attr['data-spotlight-muted'] = muted;
	}

	unload () {
		this.releaseContainer();
	}

	releaseContainer () {
		if (this.preserveId) {
			Spotlight.unmount(this.id);
		} else {
			Spotlight.remove(this.id);
		}
	}

	navigableFilter = (elem) => {
		// If the component to which this was applied specified a navigableFilter, run it
		if (typeof this.filter === 'function') {
			if (this.filter(elem) === false) {
				return false;
			}
		}

		return true;
	}

	silentBlur ({target}) {
		this.shouldPreventBlur = true;
		target.blur();
		this.shouldPreventBlur = false;
	}

	onBlurChild = handle(
		() => this.shouldPreventBlur,
		stop
	).bindAs(this, 'onBlurChild');

	onFocusChild = handle(
		forProp('spotlightDisabled', true),
		stop,
		call('silentBlur')
	).bindAs(this, 'onFocusChild');

	onPointerEnter = handle(
		isNewPointerPosition,
		() => Spotlight.setActiveContainer(this.context.state.current.id)
	).bindAs(this, 'onPointerEnter');

	onPointerLeave = handle(
		not(forProp('spotlightRestrict', 'self-only')),
		isNewPointerPosition,
		(ev) => {
			const parentContainer = ev.currentTarget.parentNode.closest('[data-spotlight-container]');
			let activeContainer = Spotlight.getActiveContainer();

			// if this container is wrapped by another and this is the currently active
			// container, move the active container to the parent
			if (parentContainer && activeContainer === this.context.state.current.id) {
				activeContainer = parentContainer.dataset.spotlightId;
				Spotlight.setActiveContainer(activeContainer);
			}
		}
	).bindAs(this, 'onPointerLeave');
}

export default SpotlightContainer;
export {
	SpotlightContainer
};
