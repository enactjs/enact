// Item.less
//
@import "../styles/variables.less";
@import "../styles/text.less";

// Defined so we don't repeat rules.
@overlay-hidden: {
	.overlay.hidden {
		display: none;
	}
};

.item {
	.moon-text-base(@moon-item-font-size);
	.moon-spotlight-padding(@moon-item-vertical-padding);

	line-height: @moon-item-line-height;
	position: relative;
	color: inherit;

	.moon-custom-text({
		font-size: @moon-item-font-size-large;
		line-height: @moon-item-line-height-large;
	});

	&.inline {
		max-width: 240px;
	}

	// Item doesn't need to be flex, just Item overlay, since it's got special children
	&.itemOverlay {
		display: flex;

		&.inline {
			display: inline-flex;
		}

		// Apply to the content area to tell it to expand to the available width of the container
		.content {
			flex: 1 1 auto;
		}
	}

	.overlay {
		line-height: 1;
		white-space: nowrap;

		&.before,
		&.after {
			> * {
				margin-top: 0;
				margin-bottom: 0;
				vertical-align: top;
			}
		}

		// Overlay has no margins, however, its edge children must be told how to behave to preserve
		// the parent's appearance. In the before, the first child must have no margin as well as
		// last child in the after. This allows them to butt up against the edges. The opposite must
		// be done for the last child of the before and the first child of the after, so they don't
		// run into the Item's content.
		&.after {
			> :first-child {
				-webkit-margin-start: @moon-icon-margin;
			}

			> :last-child {
				-webkit-margin-end: 0;
			}
		}

		&.before {
			> :first-child {
				-webkit-margin-start: 0;
			}

			> :last-child {
				-webkit-margin-end: @moon-icon-margin;
			}
		}
	}

	// Spottable but not focused
	.spottable({
		&:not(:focus) {
			@overlay-hidden();
		}
	});
	.disabled(@overlay-hidden);

	.locale-japanese-line-break();
}

.muted({
	.item {
		.focus(@overlay-hidden);
	}
});
