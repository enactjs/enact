@use "./variables";

@function default($args...) {
	@each $arg in $args {
		@if not variable-exists(#{$arg}) {
			@return true;
		}
	}
	@return false;
}

@function extract($val, $index) {
	@return nth($val, $index);
}

@function is-parent($target) {
	@return $target == parent;
}

// Disabled elements
@mixin disabled($parent: false) {
	$selector: "";
	@if $parent == false {
		$selector: "&";
	}
	@if content-exists() {
		#{$selector}[disabled] {
			@content;
		}
	}
}

// Assign font-kerning rules in a non-proprietary way. Default value being "normal", to enable kerning.
@mixin font-kerning($val: normal) {
	& {
		-webkit-font-kerning: $val;
		font-kerning: $val;
	}
}

// Applies RTL-compatible start and end position to a selector
// Simple "when" here just assumes that if the first argument is a list with more than 1 entry,
// then units are correct. If it's just 1, then we verify if the value is a number (measurement).
@mixin position-start-end($start, $end: null, $target: "") {
	@if ($start != null and $end == null and (($target == parent) or ($target == self) or ($target == ""))) {
		@include position($start);

		$top: $start;
		$left: $start;
		$bottom: $start;
		$right: $start;

		@if ((length($start) == 4)) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 3);
			$left: nth($start, 4);
		} @else if ((length($start) == 3)) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 3);
			$left: nth($start, 2);
		} @else if (length($start) == 2) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 1);
			$left: nth($start, 2);
		}

		@include enact-locale-rtl($target) {
			// Note: swapping left and right values
			@include position($top, $left, $bottom, $right);
		}
	} @else if ($start != null and $end != null) {
		left: $start;
		right: $end;

		@include enact-locale-rtl($target) {
			// Note: swapping left and right values
			left: $end;
			right: $start;
		}
	}
}

// Applies RTL-compatible start and end margins to a selector
@mixin margin-start-end($start, $end: null, $target: "") {
	@if ($start != null and $end == null and (($target == parent) or ($target == self) or ($target == ""))) {
		margin: $start;

		$top: $start;
		$left: $start;
		$bottom: $start;
		$right: $start;

		@if ((length($start) == 4)) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 3);
			$left: nth($start, 4);
		} @else if ((length($start) == 3)) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 3);
			$left: nth($start, 2);
		} @else if (length($start) == 2) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 1);
			$left: nth($start, 2);
		}

		@include enact-locale-rtl($target) {
			// Note: swapping left and right values
			margin: $top $left $bottom $right;
		}
	} @else if ($start != null and $end != null) {
		margin-left: $start;
		margin-right: $end;

		@include enact-locale-rtl($target) {
			// Note: swapping left and right values
			margin-left: $end;
			margin-right: $start;
		}
	}
}

// Applies RTL-compatible start and end padding to a selector
@mixin padding-start-end($start, $end: null, $target: "") {
	@if ($start != null and $end == null and (($target == parent) or ($target == self) or ($target == ""))) {
		& {
			padding: $start;
		}

		$top: $start;
		$left: $start;
		$bottom: $start;
		$right: $start;

		@if ((length($start) == 4)) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 3);
			$left: nth($start, 4);
		} @else if ((length($start) == 3)) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 3);
			$left: nth($start, 2);
		} @else if (length($start) == 2) {
			$top: nth($start, 1);
			$right: nth($start, 2);
			$bottom: nth($start, 1);
			$left: nth($start, 2);
		}

		@include enact-locale-rtl($target) {
			// Note: swapping left and right values
			padding: $top $left $bottom $right;
		}
	} @else if ($start != null and $end != null) {
		padding-left: $start;
		padding-right: $end;

		@include enact-locale-rtl($target) {
			// Note: swapping left and right values
			padding-left: $end;
			padding-right: $start;
		}
	}
}

// Shorthand for positioning code
@mixin positionBase($t, $r, $b, $l) {
	top: $t;
	right: $r;
	bottom: $b;
	left: $l;
}

@mixin position($trbl) {
	@if (length($trbl) == 4) {
		@include positionBase(nth($trbl, 1), nth($trbl, 2), nth($trbl, 3), nth($trbl, 4));
	} @else if (length($trbl) == 3) {
		@include positionBase(nth($trbl, 1), nth($trbl, 2), nth($trbl, 3), nth($trbl, 2));
	} @else if (length($trbl) == 2) {
		@include positionBase(nth($trbl, 1), nth($trbl, 2), nth($trbl, 1), nth($trbl, 2));
	} @else {
		@include positionBase(nth($trbl, 1), nth($trbl, 1), nth($trbl, 1), nth($trbl, 1));
	}
}

//
// Mixin classes supporting advanced text
//

// /**
//  * Generate a pair of @font-face rules for a given name and "collection" of locale fonts.
//  *
//  * This creates two (2) referenceable font-family names, one that "stacks" onto the provided "base"
//  * name, the other suffixed with the locale name. E.g. "FontName" and "FontName Locale".
//  *
//  * Example:
//  * ```
//  * $fonts: (
//  * 	as: local("LG Smart UI Bengali"), // same as `bn`
//  * 	bn: local("LG Smart UI Bengali"),
//  * 	en-JP: local("LG Smart UI JP") local("LG Display_JP_Bold") 700, // same as `ja`
//  * 	ja: local("LG Smart UI JP") local("LG Display_JP_Bold") 700, // Generates 2 entries, one for JP set to "normal" (default) weight and another for JP_Bold set to 700 weight
//  * 	ur: local("LG Smart UI_Urdu") normal 300 600 700 // Generates 4 entries, one for each weight
//  * );
//  * ```
//  *
//  * List of supported "options" per locale key, in the following order:
//  * * single font source - Typically a reference to a local() font or a url() font.
//  * * font-weight - Optional, Numbers (100, 500, 700, etc) and keywords (normal, bold, etc) are supported.
//  * 	Empty-string represents "null". This excludes the font-weight rule from the generated code.
//  * 	Multiple weights can be supplied to generate multiple sets of face rules for a single source file
//  * * font-style - Optional, Keywords (normal, italic, etc) are supported.
//  *
//  * OPTIONALLY: repeat the options above after a comma (,) for multiple weights/styles/options based on the same name.
//  *
//  * $param  {String} $baseName The name used as the basis for the generated font-family.
//  * $param  {Object} $f        Object of keys with values detailing the font variants and options.
//  */

@mixin buildLocaleFont($fontName, $locale, $args) {
	@if content-exists() {
		@include buildFontFaceBase("#{$fontName} #{$locale}", $args) {
			@content;
		}
		@include buildFontFaceBase($fontName, $args) {
			@content;
		}
	}

	$src: nth($args, 1);
	$argLast: nth($args, length($args)); // optional style value

	$styleExists: if(($argLast == italic or $argLast == oblique), true, false);  // List all valid font-style values here (except for "normal" since that is a shared keyword with font-weight)
	$style: if($styleExists, $argLast, "");
	$lastWeightArgIndex: if($styleExists, length($args) - 1, length($args));  // It's possible this could get confused if "normal" or "bold" is used as the last weight. Please use a number as the last weight.

	// Please retain the following comment for future debugging purposes. This gives insight into how the definition values are being interpreted.
	// :global(.debug-buildLocaleFont#{$fontName}-#{$locale}) {
	// 	fontName: $fontName;
	// 	locale: $locale;
	// 	args: $args;
	// 	args-count: length($args);
	// 	last-weight-arg-index: $lastWeightArgIndex;
	// 	src: $src;
	// 	styleExists: $styleExists;
	// 	style: $style;
	// }

	@if ($lastWeightArgIndex >= 2) {
		@for $argIndex from 2 through $lastWeightArgIndex {
			$weight: nth($args, $argIndex);
			@include buildFontFace("#{$fontName} #{$locale}", $src, $weight, $style);
			@include buildFontFace($fontName, $src, $weight, $style);
		}
	}

	@if (length($args) <= 1) {
		@include buildFontFaceBase("#{$fontName} #{$locale}", $src);
		@include buildFontFace($fontName, $src);
	}
}

@mixin buildLocaleFonts($fontName, $f) {
	@each $specs, $locale in $f {
		// Determine if we're working with a collection of font definitions or an individual definition
		$isCollection: if(((length($specs) > 1) and ((length(nth($specs, 1)) > 1) or (length(nth($specs, 2)) > 1))), true, false);

		// :global(.debug-buildLocaleFonts-#{$locale}) {
		// 	is-collection: $isCollection;
		// }

		@if ($isCollection) {
			// Interpret collections of font definitions: [(set1) (set2) (set3)]
			@each $value in $specs {
				@include buildLocaleFont($fontName, $locale, $value);
			}
		} @else {
			// Interpret individual font definitions: (set1)
			@include buildLocaleFont($fontName, $locale, $specs);
		}
		// @include debugLessTypes($specs);
	}
}

// /**
//  * Generate a single @font-face rule.
//  *
//  * List of supported "options" per locale key, in the following order:
//  * $param  {String} font-family name   The generated font name, referenceable via
//  *                                     `font-family: <name>;` in normal CSS.
//  * $param  {URL} single font source    Typically a reference to a local() font or a url() font.
//  * $param  {Number|Keyword|""} font-weight  Optional, Numbers (100, 500, 700, etc) and keywords
//  *                                     (normal, bold, etc) are supported. Empty-string represents
//  *                                     "null" or default. This excludes the weight rule from the generated code.
//  * $param  {Keyword} font-style        Optional, Keywords (normal, italic, etc) are supported.
//  */

@mixin buildFontFaceBase($name, $src) {
	@font-face {
		font-family: $name;
		src: $src;
		@content;
	}
}

@mixin buildFontFace($name, $src, $weight: normal, $style: "") {
	@if (length($weight) > 1) {
		@each $value in $weight {
			@include buildFontFaceBase($name, $src) {
				font-weight: $value;
			}
		}
		@include buildFontFaceBase($name, $src) {
			font-style: $style;
			@content;
		}
	} @else {
		@include buildFontFaceBase($name, $src) {
			font-weight: $weight;
			font-style: $style;
			@content;
		}
	}
}

//
// Locale Mixins
//

// @mixin enact-locale-line-height
//
// Assign line-height rules specifically to the languages designated
// as needing special support for tall-glyphs.
//
// Set line-height for normal and tallglyphs with 1 list argument
// Ex:
//   @include enact-locale-line-height(1.4em 1.6em);
// Or:
//   $lineheight: 1.4em 1.6em;
//   @include enact-locale-line-height($lineheight);
@mixin enact-locale-line-height($both, $target: normal) {
	@include enact-locale-tallglyph-values(line-height, $both, $target);
}

// @mixin enact-locale-tallglyph
//
// Rulename and a normal value followed by a tallglyph value (3 arguments)
// Ex:
//   @include enact-locale-tallglyph(font-size, 1.4em; 1.6em, normal);  ->  normal font-size: 1.4em; tallglyphs font-size: 1.6em;

@mixin enact-locale-tallglyph($rule, $normal, $tallglyph, $target, $locale-tallglyph-languages: "") {
	& {
		#{$rule}: $normal;
	}
	@include enact-locale-tallglyph-values($rule, $tallglyph, $target, $locale-tallglyph-languages);
}

@mixin enact-locale-tallglyph-values($rule, $val, $target: normal, $locale-tallglyph-languages: "") {
	$locale-tallglyph-languages: if($locale-tallglyph-languages == "", variables.$locale-tallglyph-languages, $locale-tallglyph-languages);

	@if (length($val) == 2) {
		// Rulename and 2 value second variable (2 arguments, 2nd being a list)
		// Ex:
		//   @include enact-locale-tallglyph(font-size; 1.4em 1.6em);  ->  normal font-size: 1.4em; tallglyphs font-size: 1.6em;
		// Or:
		//   $fontsize: 1.4em 1.6em;
		//   @include enact-locale-tallglyph(font-size, $fontsize);    ->  normal font-size: 1.4em; tallglyphs font-size: 1.6em;
		#{$rule}: extract($val, 1);
		@each $value in $locale-tallglyph-languages {
			@include enact-locale($value, $target) {
				#{$rule}: extract($val, 2);
			}
		}
	} @else {
		// Rulename and a tallglyph value
		// Ex:
		//   @include enact-locale-tallglyph(font-size; 1.6em);  ->  tallglyphs font-size: 1.6em;
		@each $value in $locale-tallglyph-languages {
			// Take each language in the list, apply the $rules to them.
			// $value is used to generate an appropriate selector for the $rules.
			@include enact-locale($value, $target) {
				#{$rule}: $val;
			}
		}
	}
}

// Assign rules specifically to RTL locales with a convenient shorthand.
@mixin enact-locale-rtl($target) {
	@include enact-locale(right-to-left, $target) {
		@content;
	}
}

// Generates an appropriate selector given the locale-target, and injects the given rules into it.
@mixin enact-locale($locale-target, $target: normal) {
	@if type-of($locale-target) == string and content-exists() and $target == self {
		&:global(.enact-locale-#{$locale-target}) {
			@content;
		}
	} @else if type-of($locale-target) == string and content-exists() and (($target == normal) or ($target == "")) {
		:global(.enact-locale-#{$locale-target}) & {
			@content;
		}
	}
}

@mixin locale-japanese-line-break {
	@include enact-locale(ja) {
		line-break: strict;
	}
}
