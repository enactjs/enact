// Disabled elements
.disabled(@rules; @target) when (isruleset(@rules)) and (@target = parent) {
	[disabled] {
		@rules();
	}
}
.disabled(@rules) when (isruleset(@rules)) {
	&[disabled] {
		@rules();
	}
}

.enact-composite() {
	-webkit-transform: translateZ(0);
	-ms-transform: translateZ(0);
	-o-transform: translateZ(0);
	transform: translateZ(0);
	will-change: transform;
}

// Applies RTL-compatible start and end position to a selector
.position-start-end (@start, @end) {
	left: @start;
	right: @end;

	:global(.enact-locale-right-to-left) & {
		left: @end;
		right: @start;
	}
}

// Applies RTL-compatible start and end margins to a selector
.margin-start-end(@start; @end; @target) when (@target = parent) {
    margin-left: @start;
    margin-right: @end;

    :global(.enact-locale-right-to-left)& {
        margin-left: @end;
        margin-right: @start;
    }
}

.margin-start-end (@start, @end) {
	margin-left: @start;
	margin-right: @end;

	:global(.enact-locale-right-to-left) & {
		margin-left: @end;
		margin-right: @start;
	}
}

// Applies RTL-compatible start and end padding to a selector
.padding-start-end(@start; @end; @target) when (@target = parent) {
    padding-left: @start;
    padding-right: @end;

    :global(.enact-locale-right-to-left)& {
        padding-left: @end;
        padding-right: @start;
    }
}

.padding-start-end (@start, @end) {
	padding-left: @start;
	padding-right: @end;

	:global(.enact-locale-right-to-left) & {
		padding-left: @end;
		padding-right: @start;
	}
}

// NOTE: Until we are able to automatically remove these JSDoc-style comments, they should remain LESS-commented
// /**
//  * Removes the margin from the appropriate side of the child components that touch the edges of the
//  * component this is applied to. This respects both LTR and RTL modes.
//  */
.remove-margin-on-edge-children() {
	> :first-child {
		-webkit-margin-start: 0;
	}

	> :last-child {
		-webkit-margin-end: 0;
	}
}

// /**
//  * Removes the padding from the appropriate side of the child components that touch the edges of the
//  * component this is applied to. This respects both LTR and RTL modes.
//  */
.remove-padding-on-edge-children() {
	> :first-child {
		-webkit-padding-start: 0;
	}

	> :last-child {
		-webkit-padding-end: 0;
	}
}


.full-screen-video-player() {
	position: static !important;
	display: block !important;
	margin: 0;
}

.hide-full-screen-ancestor() {
	position: absolute !important;
	overflow: visible !important;
	padding: 0 !important;
	margin: 0 !important;
	width: 100% !important;
	height: 100% !important;
}

.input-placeholder(@rule) {
	&::-webkit-input-placeholder {
		@rule();
	}
	&::-moz-placeholder {
		@rule();
	}
}

// Asign font-kerning rules in a non-proprietary way. Default value being "normal", to enable kerning.
.font-kerning(@val: normal) {
	-webkit-font-kerning: @val;
	font-kerning: @val;
}

// Provide a set of rules to assign to each vendor-prefixed pseudo selector
.vendor-fullscreen(@rule) {
	&:-webkit-full-screen { @rule(); }
	&:-moz-full-screen { @rule(); }
	&:-ms-fullscreen { @rule(); }
	&:-o-full-screen { @rule(); }
	&:fullscreen { @rule(); }
}

.vendor-opacity(@opacity) {
	@opacity-ie: (@opacity * 100);	// Less doesn't like math inside `alpha`
	opacity: @opacity;
	filter: alpha(opacity=@opacity-ie);
}

// Shorthand for positioning code
.position (@t, @r, @b, @l) {
	top: @t;
	right: @r;
	bottom: @b;
	left: @l;
}
.position (@t, @rl, @b) {
	top: @t;
	right: @rl;
	bottom: @b;
	left: @rl;
}
.position (@tb, @rl) {
	top: @tb;
	right: @rl;
	bottom: @tb;
	left: @rl;
}
.position (@trbl) {
	top: @trbl;
	right: @trbl;
	bottom: @trbl;
	left: @trbl;
}

.border-box() {
	box-sizing: border-box;
	-moz-box-sizing: border-box;
}

//
// Mixin classes supporting advanced text
//

// /**
//  * Generate a pair of @font-face rules for a given name and "collection" of locale fonts.
//  *
//  * This creates two (2) referenceable font-family names, one that "stacks" onto the provided "base"
//  * name, the other suffixed with the locale name. E.g. "FontName" and "FontName Locale".
//  *
//  * Example:
//  * ```
//  * @fonts: {
//  * 	as: local("LG Smart UI Bengali"); // same as `bn`
//  * 	bn: local("LG Smart UI Bengali");
//  * 	en-JP: local("LG Smart UI JP") "", local("LG Display_JP_Bold") 700; // same as `ja`
//  * 	ja: local("LG Smart UI JP") "", local("LG Display_JP_Bold") 700;
//  * };
//  * ```
//  *
//  * List of supported "options" per locale key, in the following order:
//  * * single font source - Typically a reference to a local() font or a url() font.
//  * * font-weight - Optional, Numbers (100, 500, 700, etc) and keywords (normal, bold, etc) are supported.
//  * 	Empty-string represents "null" or default. This excludes the weight rule from the generated code.
//  * * font-style - Optional, Keywords (normal, italic, etc) are supported.
//  *
//  * OPTIONALLY: repeat the options above after a comma (,) for multiple weights/styles/options based on the same name.
//  *
//  * @param  {String} @baseName The name used as the basis for the generated font-family.
//  * @param  {Object} @f        Object of keys with values detailing the font variants and options.
//  */
.buildLocaleFonts(@fontName, @f) {
	each(@f, .(@specs, @locale) {
		each(@specs, {
			@f-weight: if((length(@value) >= 2), extract(@value, 2));
			@f-style: if((length(@value) >= 3), extract(@value, 3));

			.buildFontFace("@{fontName} @{locale}"; extract(@value, 1); @f-weight; @f-style);
			.buildFontFace(@fontName;               extract(@value, 1); @f-weight; @f-style);
		});
	});
};

// /**
//  * Generate a single @font-face rule.
//  *
//  * List of supported "options" per locale key, in the following order:
//  * @param  {String} font-family name   The generated font name, referenceable via
//  *                                     `font-family: <name>;` in normal CSS.
//  * @param  {URL} single font source    Typically a reference to a local() font or a url() font.
//  * @param  {Number|Keyword|""} font-weight  Optional, Numbers (100, 500, 700, etc) and keywords
//  *                                     (normal, bold, etc) are supported. Empty-string represents
//  *                                     "null" or default. This excludes the weight rule from the generated code.
//  * @param  {Keyword} font-style        Optional, Keywords (normal, italic, etc) are supported.
//  */
.buildFontFace(@name; @src; @weight: ""; @style: "") {
	@font-face {
		font-family: @name;
		src: @src;

		// Conditionally add the following
		// `length()` below refers to specifying font-weight ranges: `600 900`.
		& when ((iskeyword(@weight)) or (isnumber(@weight)) or (length(@weight) > 1)) {
			font-weight: @weight;
		}
		& when (iskeyword(@style)) {
			font-style: @style;
		}
	}
}

.locale-japanese-line-break() {
	:global(.enact-locale-ja) & {
		line-break: strict;
	}
}
